<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFTDriveData</title>
    <script src="bundle.min.js"></script>
    <script src="aes.js"></script>
</head>

<head>
    <style>
        .accordion {
            background-color: #eee;
            cursor: pointer;
            padding: 10px;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-weight: bold;
            margin-top: 5px;
        }

        .accordion.active,
        .accordion:hover {
            background-color: #ccc;
        }

        .panel {
            padding: 10px;
            display: none;
            background-color: white;
            border: 1px solid #ccc;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .loader {
            border: 8px solid #f3f3f3;
            border-top: 8px solid #3f51b5;
            border-radius: 50%;
            width: 48px;
            height: 48px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px auto;
        }

        .progress-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
        }

        .progress-bar-wrapper {
            width: 100%;
            height: 30px;
            background-color: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin: 10px 0;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3f51b5, #5c6bc0);
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }

        .progress-message {
            text-align: center;
            margin-top: 10px;
            color: #333;
            font-size: 14px;
        }

        .progress-details {
            text-align: center;
            margin-top: 5px;
            color: #666;
            font-size: 12px;
        }

        #progressContainer {
            display: none;
        }

        #progressContainer.show {
            display: block;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .preview {
            margin: 20px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            max-width: calc(100% - 40px);
            max-height: calc(100vh - 100px);
            overflow: auto;
        }

        .preview img {
            max-width: 100%;
            max-height: calc(100vh - 150px);
            height: auto;
            width: auto;
            display: block;
            object-fit: contain;
            cursor: zoom-in;
            transition: transform 0.2s ease;
        }

        .preview img.zoomed {
            cursor: zoom-out;
        }

        .zoom-container {
            position: relative;
            display: inline-block;
            overflow: auto;
            max-width: 100%;
            max-height: calc(100vh - 150px);
            user-select: none;
        }

        .zoom-container img {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .preview video,
        .preview audio {
            max-width: 100%;
            display: block;
        }

        .preview iframe {
            max-width: 100%;
            display: block;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        h1 {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>

<body>
    <div>
        <!-- <h1>NFTDriveData</h1> -->
        <div id="progressContainer" class="progress-container">
            <div class="loader"></div>
            <div class="progress-bar-wrapper">
                <div id="progressBar" class="progress-bar" style="width: 0%">0%</div>
            </div>
            <div id="progressMessage" class="progress-message">èª­ã¿è¾¼ã¿ä¸­...</div>
            <div id="progressDetails" class="progress-details"></div>
        </div>
        <div id="preview" class="preview"></div>
        <div id="result"></div>
        <div id="accordion-container"></div>
    </div>

    <script>
        const NODELIST = {
            mainnet: [
                "https://sn1.msus-symbol.com:3001",
                "https://ichigo-node.xyz:3001",
                "https://0-0-0-0.symbol-nodes.jp:3001",
                "https://01.symbol-node.com:3001",
                "https://03.symbol-node.com:3001",
                "https://symbol-node.teritaris.net:3001",
                "https://symbol-no:3001"
            ],
            testnet: [
                "https://201-sai-dual.symboltest.net:3001",
                "https://testnet1.symbol-mikun.net:3001",
                "https://testnet2.symbol-mikun.net:3001",
                "https://sym-test-03.opening-line.jp:3001",
                "https://001-sai-dual.symboltest.net:3001",
                "https://vmi831828.contaboserver.net:3001",
                "https://symbol-azure.0009.co:3001"
            ]
        }

        function shuffleArray(array) {
            const shuffled = [...array]; // ã‚³ãƒ”ãƒ¼ã‚’ä½œæˆ

            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                // è¦ç´ ã‚’äº¤æ›
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            return shuffled;
        }

        // ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
        function getNetworkFromAddress(address) {
            if (!address || address.length === 0) return 'mainnet';
            const firstChar = address.charAt(0).toUpperCase();
            return firstChar === 'N' ? 'mainnet' : 'testnet';
        }

        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«å¿œã˜ãŸãƒ•ã‚§ãƒƒãƒãƒ£ãƒ¼ã‚’åˆæœŸåŒ–
        let fetcher;

        function initializeFetcher(address) {
            const network = getNetworkFromAddress(address);
            shuffleNode = shuffleArray(NODELIST[network]);
            fetcher = new SymbolTransactionFetcher(shuffleNode);
        }

        // URLã®GETãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰addressã‚’å–å¾—ã™ã‚‹é–¢æ•°
        function getAddressFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('address');
        }

        // NFTDriveDataã‚’å–å¾—ã—ã¦è¡¨ç¤ºã™ã‚‹å‡¦ç†
        function fetchAndDisplayNFTDriveData(address) {
            if (!address) {
                console.error("ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
                return;
            }

            initializeFetcher(address);

            // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’è¡¨ç¤º
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressMessage = document.getElementById('progressMessage');
            const progressDetails = document.getElementById('progressDetails');
            const preview = document.getElementById('preview');

            progressContainer.classList.add('show');
            preview.innerHTML = '';

            // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ç›£è¦–ã‚¿ã‚¤ãƒãƒ¼
            let progressTimer = setInterval(() => {
                const progress = fetcher.getProgress();
                
                // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’æ›´æ–°
                progressBar.style.width = progress.percentage + '%';
                progressBar.textContent = progress.percentage + '%';
                progressMessage.textContent = progress.message || 'èª­ã¿è¾¼ã¿ä¸­...';
                
                if (progress.details && progress.details.total > 0) {
                    progressDetails.textContent = `${progress.details.fetched} / ${progress.details.total} ä»¶å–å¾—æ¸ˆã¿`;
                }
            }, 100);

            fetcher.fetchAllAggregatesStable(address,  {
                indexNodeIndex: 0,
                indexPageSize: 100,
                indexTypes :[16705], // å¿…è¦ãªã‚‰ [16705, 16961]
                concurrency:2,
                retries:3
            }).then(async (result) => {

                await fetcher.getNFTDriveData(result, { debugger: true })
                    .then(async (sortedAggTxes) => {

                        // ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º
                        renderAccordionFromObject(sortedAggTxes);
                        base64Preview(sortedAggTxes.header, sortedAggTxes.data, document.getElementById('preview'));

                        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹å®Œäº†
                        clearInterval(progressTimer);
                        setTimeout(() => {
                            progressContainer.classList.remove('show');
                        }, 500);

                        // ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰æ™‚ã«æ¬ æãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³åˆ†æã‚’è¡¨ç¤º
                        if (sortedAggTxes.debugInfo.lostCount > 0) {
                            sortedAggTxes.debugInfo.aggregateTransactions = result;
                            displayLostTransactionAnalysis(sortedAggTxes.debugInfo);
                        }
                    })
                    .catch(err => {
                        console.error("NFTDriveDataç”Ÿæˆã‚¨ãƒ©ãƒ¼:", err);
                        clearInterval(progressTimer);
                        progressContainer.classList.remove('show');
                        preview.innerHTML = '<p style="color: red;">ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>';
                    });
            }).catch(err => {
                console.error("å®‰å®šç‰ˆã‚¢ã‚°ãƒªã‚²ãƒ¼ãƒˆãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å–å¾—ã‚¨ãƒ©ãƒ¼:", err);
                clearInterval(progressTimer);
                progressContainer.classList.remove('show');
                preview.innerHTML = '<p style="color: red;">ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å–å¾—ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>';
            });

        }


        // ãƒšãƒ¼ã‚¸ãƒ­ãƒ¼ãƒ‰æ™‚ã«GETãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
        window.addEventListener('DOMContentLoaded', function () {
            let addressFromURL = getAddressFromURL();

            // GETãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒãªã„å ´åˆã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã§å…¥åŠ›
            if (!addressFromURL) {
                addressFromURL = prompt("NFTDriveãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š");
                if (!addressFromURL) {
                    document.getElementById('preview').innerHTML = `<p style="color: blue;">ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå…¥åŠ›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚</p>`;
                    return;
                }
            }
            // è‡ªå‹•çš„ã«ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚’å®Ÿè¡Œ
            fetchAndDisplayNFTDriveData(addressFromURL);

        });

        // ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ã®è¡¨ç¤º
        function renderAccordionFromObject(obj, containerId = 'accordion-container') {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            Object.keys(obj).forEach(key => {
                // ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³ãƒœã‚¿ãƒ³
                const btn = document.createElement('button');
                btn.className = 'accordion';
                btn.textContent = key;

                // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ‘ãƒãƒ«
                const panel = document.createElement('div');
                panel.className = 'panel';
                panel.textContent = typeof obj[key] === 'object'
                    ? JSON.stringify(obj[key], null, 2)
                    : String(obj[key]);

                // ãƒˆã‚°ãƒ«å‡¦ç†
                btn.addEventListener('click', () => {
                    panel.style.display = (panel.style.display === 'block') ? 'none' : 'block';
                    btn.classList.toggle('active');
                });

                container.appendChild(btn);
                container.appendChild(panel);
            });
        }

        let TextDecoderClass;

        // Node.js ç’°å¢ƒã§ã¯ `util.TextDecoder` ã‚’ä½¿ç”¨
        if (typeof window === 'undefined') {
            const { TextDecoder } = require('util');
            TextDecoderClass = TextDecoder;
        } else {
            TextDecoderClass = TextDecoder;
        }


        // 16é€²æ•°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ã™ã‚‹é–¢æ•°
        function decodeHexMessage(hex) {
            if (!hex || hex.length < 2) return '';
            const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));
            const decoder = new TextDecoderClass('utf-8');
            // å…ˆé ­1ãƒã‚¤ãƒˆã¯ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¿ã‚¤ãƒ—ãªã®ã§é™¤å¤–
            let decoded = decoder.decode(bytes.subarray(1))
            // æ–‡å­—åˆ—ã®æœ€åˆã¨æœ€å¾Œã®ç©ºç™½ã‚’å‰Šé™¤
            return decoded;
        }



        // Base64ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é–¢æ•°
        function base64Preview(header, base64Data, containerElement) {

            // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›
            console.log("=== base64Preview ãƒ‡ãƒãƒƒã‚°æƒ…å ± ===");
            console.log("ãƒ˜ãƒƒãƒ€ãƒ¼:", header);
            console.log("Base64ãƒ‡ãƒ¼ã‚¿é•·:", base64Data.length);
            console.log("Base64ãƒ‡ãƒ¼ã‚¿å…ˆé ­200æ–‡å­—:", base64Data.substring(0, 200));
            console.log("Base64ãƒ‡ãƒ¼ã‚¿æœ«å°¾200æ–‡å­—:", base64Data.substring(Math.max(0, base64Data.length - 200)));



            // æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆSaltä»˜ãBase64ã®ç‰¹å¾´ï¼šU2FsdGVkX1ã§å§‹ã¾ã‚‹ï¼‰
            const isEncrypted = base64Data.startsWith('U2FsdGVkX1');

            if (isEncrypted) {
                console.log("æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");
                handleEncryptedData(base64Data, containerElement);
                return;
            }



            // JSON Base64ã®åˆ¤å®šã¨å‡¦ç†
            if (base64Data.startsWith('eyJ')) {
                try {
                    const jsonString = atob(base64Data);
                    const jsonData = JSON.parse(jsonString);

                    const container = document.createElement("div");
                    container.style.padding = "15px";
                    container.style.backgroundColor = "#f5f5f5";
                    container.style.borderRadius = "5px";
                    container.style.whiteSpace = "pre-wrap";
                    container.style.wordWrap = "break-word";
                    container.textContent = JSON.stringify(jsonData, null, 2);
                    containerElement.appendChild(container);
                    return;
                } catch (e) {
                    console.error("JSON ãƒ‘ãƒ¼ã‚¹å¤±æ•—:", e.message);
                }
            }


            // é€šå¸¸ã®Base64å‡¦ç†
            const match = base64Data.match(/^data:([^;]+);base64,(.*)$/);
            if (!match) {
                containerElement.innerHTML = `<p style="color: red;">ã‚¨ãƒ©ãƒ¼ï¼šæœ‰åŠ¹ãªBase64ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“<br/>
                ãƒ‡ãƒ¼ã‚¿å…ˆé ­: ${base64Data.substring(0, 100)}</p>`;
                return;
            }

            renderPreview(match[1], match[2], containerElement);
        }

        // æš—å·åŒ–ãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ã™ã‚‹é–¢æ•°
        function handleEncryptedData(encryptedBase64, containerElement) {
            const password = prompt("ã“ã®NFTDriveãƒ‡ãƒ¼ã‚¿ã¯æš—å·åŒ–ã•ã‚Œã¦ã„ã¾ã™ã€‚\nãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š");

            if (password === null) {
                containerElement.innerHTML = `<p style="color: blue;">ãƒ‡ãƒ¼ã‚¿ã®å¾©å·åŒ–ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸã€‚</p>`;
                return;
            }

            try {
                // CryptoJS.AES.decryptã‚’ä½¿ç”¨ã—ã¦å¾©å·åŒ–
                const decrypted = CryptoJS.AES.decrypt(encryptedBase64, password);
                const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);

                if (!decryptedString) {
                    throw new Error("å¾©å·åŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ­£ã—ããªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
                }

                // å¾©å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒBase64å½¢å¼ã‹ã©ã†ã‹ã‚’åˆ¤å®š
                const match = decryptedString.match(/^data:([^;]+);base64,(.*)$/);
                if (!match) {
                    // å¾©å·åŒ–ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ãŒãã®ã¾ã¾Base64ã®å ´åˆ
                    renderPreview("application/octet-stream", decryptedString, containerElement);
                } else {
                    // MIMEã‚¿ã‚¤ãƒ—ä»˜ãã®å ´åˆ
                    renderPreview(match[1], match[2], containerElement);
                }

            } catch (error) {
                console.error("å¾©å·åŒ–ã‚¨ãƒ©ãƒ¼:", error.message);
                containerElement.innerHTML = `<p style="color: red;">ã‚¨ãƒ©ãƒ¼ï¼š${error.message}</p>`;
            }
        }

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤ºã®å…±é€šå‡¦ç†
        function renderPreview(mimeType, base64Data, containerElement) {
            let base64 = base64Data;

            // Base64ãŒç©ºã®å ´åˆ
            if (!base64 || base64.length === 0) {
                console.error("Base64ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™");
                containerElement.innerHTML = `<p style="color: red;">ã‚¨ãƒ©ãƒ¼ï¼šBase64ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™</p>`;
                return;
            }

            console.log("renderPreviewå‰:", "é•·ã•", base64.length, "% 4 =", base64.length % 4);


            let binaryData;
            try {
                console.log("atobå®Ÿè¡Œå‰:", "é•·ã•", base64.length, "æœ«å°¾", base64.substring(base64.length - 5));
                binaryData = atob(base64);
                console.log("âœ“ atobæˆåŠŸ:", "ãƒã‚¤ãƒŠãƒªé•·", binaryData.length);
            } catch (e) {
                console.error("âŒ Base64 decode ã«å¤±æ•—:", e.message);
                console.error("  Base64ãƒ‡ãƒ¼ã‚¿é•·:", base64.length);
                console.error("  é•·ã• % 4:", base64.length % 4);
                console.error("  æœ«å°¾20æ–‡å­—:", base64.substring(base64.length - 20));
                console.error("  å…ˆé ­100æ–‡å­—:", base64.substring(0, 100));

                containerElement.innerHTML = `<p style="color: red;">ã‚¨ãƒ©ãƒ¼ï¼šBase64ãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•—<br/>
                å½¢å¼: ${mimeType}<br/>
                ãƒ‡ãƒ¼ã‚¿é•·: ${base64.length}<br/>
                è©³ç´°: ${e.message}</p>`;
                return;
            }


            // ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ãŒç©ºã®å ´åˆ
            if (!binaryData || binaryData.length === 0) {
                console.error("ãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œã®ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™");
                containerElement.innerHTML = `<p style="color: red;">ã‚¨ãƒ©ãƒ¼ï¼šãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œã®ãƒ‡ãƒ¼ã‚¿ãŒç©ºã§ã™</p>`;
                return;
            }

            // Base64ãƒ‡ãƒ¼ã‚¿ã‚’Uint8Arrayã«å¤‰æ›
            const byteArray = new Uint8Array(binaryData.length);
            for (let i = 0; i < binaryData.length; i++) {
                byteArray[i] = binaryData.charCodeAt(i);
            }




            // // â˜… WAV ãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
            // if (mimeType === 'audio/wav') {
            //     const wavMetadata = analyzeWAVMetadata(byteArray);
            //     displayWAVAnalysis(wavMetadata);
            // }


            const blob = new Blob([byteArray], { type: mimeType });
            const blobURL = URL.createObjectURL(blob);

            console.log("âœ“ MIME:", mimeType, "ãƒ‡ãƒ¼ã‚¿é•·:", byteArray.length);

            containerElement.innerHTML = "";

            let element;
            switch (mimeType) {

                case "image/png":
                case "image/jpeg":
                case "image/gif":
                case "image/webp":
                    const zoomContainer = document.createElement("div");
                    zoomContainer.className = "zoom-container";

                    element = document.createElement("img");
                    element.src = blobURL;
                    element.alt = "ç”»åƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼";
                    element.style.maxWidth = "100%";
                    element.style.maxHeight = "calc(100vh - 150px)";
                    element.style.height = "auto";
                    element.style.width = "auto";
                    element.style.display = "block";
                    element.style.objectFit = "contain";
                    element.style.userSelect = "none";
                    element.style.webkitUserSelect = "none";
                    element.draggable = false;

                    let scale = 1;
                    const maxScale = 5; // æœ€å¤§5å€ã¾ã§ã‚ºãƒ¼ãƒ 
                    let isDragging = false;
                    let startX = 0;
                    let startY = 0;
                    let scrollLeft = 0;
                    let scrollTop = 0;

                    // ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
                    element.addEventListener('wheel', (e) => {
                        if (!e.ctrlKey) {
                            e.preventDefault();
                            const delta = e.deltaY > 0 ? -0.1 : 0.1;
                            scale = Math.max(1, Math.min(maxScale, scale + delta));
                            element.style.transform = `scale(${scale})`;
                            element.style.transformOrigin = "center center";

                            if (scale > 1) {
                                element.classList.add('zoomed');
                                zoomContainer.style.overflow = "auto";
                            } else {
                                element.classList.remove('zoomed');
                                zoomContainer.style.overflow = "auto";
                            }
                        }
                    }, { passive: false });

                    // ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§ã‚ºãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
                    element.addEventListener('dblclick', () => {
                        scale = 1;
                        element.style.transform = `scale(${scale})`;
                        element.classList.remove('zoomed');
                        zoomContainer.scrollLeft = 0;
                        zoomContainer.scrollTop = 0;
                    });

                    // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³ã§ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                    element.addEventListener('mousedown', (e) => {
                        if (scale > 1 && e.button === 0) { // å·¦ã‚¯ãƒªãƒƒã‚¯ã®ã¿
                            isDragging = true;
                            startX = e.clientX;
                            startY = e.clientY;
                            scrollLeft = zoomContainer.scrollLeft;
                            scrollTop = zoomContainer.scrollTop;
                            element.style.cursor = "grabbing";
                            e.preventDefault();
                        }
                    });

                    // ãƒã‚¦ã‚¹ãƒ ãƒ¼ãƒ–ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                    const handleMouseMove = (e) => {
                        if (!isDragging) return;

                        const x = e.clientX;
                        const y = e.clientY;
                        const walkX = (x - startX) * 1.5; // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«æ„Ÿåº¦èª¿æ•´
                        const walkY = (y - startY) * 1.5;

                        zoomContainer.scrollLeft = scrollLeft - walkX;
                        zoomContainer.scrollTop = scrollTop - walkY;
                    };

                    // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—ã§ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
                    const handleMouseUp = () => {
                        isDragging = false;
                        element.style.cursor = scale > 1 ? "grab" : "zoom-in";
                    };

                    // ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
                    document.addEventListener('mousemove', handleMouseMove, false);
                    document.addEventListener('mouseup', handleMouseUp, false);

                    // ã‚ºãƒ¼ãƒ ã•ã‚Œã¦ã„ãªã„æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¼ã‚½ãƒ«
                    element.addEventListener('mouseover', () => {
                        if (scale > 1) {
                            element.style.cursor = "grab";
                        } else {
                            element.style.cursor = "zoom-in";
                        }
                    });

                    element.addEventListener('mouseleave', () => {
                        if (!isDragging) {
                            element.style.cursor = "default";
                        }
                    });

                    // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒ†ã‚­ã‚¹ãƒˆé¸æŠã‚’é˜²æ­¢
                    element.addEventListener('selectstart', (e) => {
                        if (isDragging) {
                            e.preventDefault();
                        }
                    });

                    // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹ç”¨ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ 
                    let lastDistance = 0;
                    element.addEventListener('touchmove', (e) => {
                        if (e.touches.length === 2) {
                            e.preventDefault();
                            const touch1 = e.touches[0];
                            const touch2 = e.touches[1];
                            const distance = Math.hypot(
                                touch2.clientX - touch1.clientX,
                                touch2.clientY - touch1.clientY
                            );

                            if (lastDistance > 0) {
                                const ratio = distance / lastDistance;
                                scale = Math.max(1, Math.min(maxScale, scale * ratio));
                                element.style.transform = `scale(${scale})`;
                                element.style.transformOrigin = "center center";

                                if (scale > 1) {
                                    element.classList.add('zoomed');
                                } else {
                                    element.classList.remove('zoomed');
                                }
                            }
                            lastDistance = distance;
                        }
                    }, { passive: false });

                    element.addEventListener('touchend', () => {
                        lastDistance = 0;
                    });

                    zoomContainer.appendChild(element);
                    containerElement.appendChild(zoomContainer);
                    return;


                case "video/mp4":
                case "video/webm":
                    element = document.createElement("video");
                    element.src = blobURL;
                    element.controls = true;
                    element.style.maxWidth = "100%";
                    element.style.height = "auto";
                    element.style.display = "block";
                    break;

                case "audio/mpeg":
                case "audio/wav":
                case "audio/ogg":
                    element = document.createElement("audio");
                    element.src = blobURL;
                    element.controls = true;
                    element.style.maxWidth = "100%";
                    element.style.display = "block";
                    break;




                case "application/pdf":
                    element = document.createElement("iframe");
                    element.src = blobURL;
                    element.style.width = "100%";
                    element.style.height = "100vh";
                    element.style.minHeight = "100vh";
                    element.style.border = "none";
                    element.style.display = "block";
                    element.onload = function () {
                        // iframeãŒèª­ã¿è¾¼ã¾ã‚ŒãŸã‚‰é«˜ã•ã‚’èª¿æ•´
                        try {
                            const iframeDoc = element.contentDocument || element.contentWindow.document;
                            if (iframeDoc && iframeDoc.body) {
                                const scrollHeight = iframeDoc.body.scrollHeight;
                                element.style.height = (scrollHeight + 20) + "px";
                            }
                        } catch (e) {
                            console.warn("iframeã®é«˜ã•èª¿æ•´ã«å¤±æ•—ï¼ˆã‚¯ãƒ­ã‚¹ã‚ªãƒªã‚¸ãƒ³ã®å¯èƒ½æ€§ï¼‰:", e);
                            element.style.height = "100vh";
                        }
                    };
                    break;


                case "text/plain":
                    // â˜… text/plainã®å ´åˆã€ã¾ãšBase64ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«ãƒ‡ã‚³ãƒ¼ãƒ‰
                    let plainTextContent = '';
                    try {
                        // Base64 â†’ ãƒã‚¤ãƒŠãƒªã«å¤‰æ›
                        const binaryString = atob(base64Data);

                        // â˜… ãƒã‚¤ãƒŠãƒª â†’ UTF-8ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆæ–‡å­—åŒ–ã‘å¯¾ç­–ï¼‰
                        const uint8Array = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            uint8Array[i] = binaryString.charCodeAt(i);
                        }
                        const decoder = new TextDecoder('utf-8');
                        plainTextContent = decoder.decode(uint8Array);

                        console.log("âœ“ Base64ãƒ‡ã‚³ãƒ¼ãƒ‰æˆåŠŸ:", plainTextContent.substring(0, 100));
                    } catch (e) {
                        console.error("Base64ãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•—:", e.message);
                        element = document.createElement("p");
                        element.style.color = "red";
                        element.textContent = `ã‚¨ãƒ©ãƒ¼ï¼šBase64ãƒ‡ã‚³ãƒ¼ãƒ‰å¤±æ•— - ${e.message}`;
                        containerElement.appendChild(element);
                        return;
                    }

                    // ãƒ‡ã‚³ãƒ¼ãƒ‰å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆãŒJSONã‹ã©ã†ã‹ã‚’åˆ¤å®š
                    try {
                        const jsonData = JSON.parse(plainTextContent);

                        // JSONãƒ‘ãƒ¼ã‚¹æˆåŠŸ â†’ JSONè¡¨ç¤º
                        element = document.createElement("div");
                        element.style.padding = "15px";
                        element.style.backgroundColor = "#f5f5f5";
                        element.style.borderRadius = "5px";
                        element.style.whiteSpace = "pre-wrap";
                        element.style.wordWrap = "break-word";
                        element.style.fontFamily = "monospace";
                        element.style.fontSize = "12px";
                        element.style.maxHeight = "80vh";
                        element.style.overflow = "auto";
                        element.style.border = "1px solid #ddd";
                        element.textContent = JSON.stringify(jsonData, null, 2);

                        console.log("âœ“ JSONå½¢å¼ã§è¡¨ç¤ºã—ã¾ã™");
                    } catch (e) {
                        // JSONãƒ‘ãƒ¼ã‚¹å¤±æ•— â†’ ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤º
                        element = document.createElement("div");
                        element.style.padding = "15px";
                        element.style.backgroundColor = "#f9f9f9";
                        element.style.borderRadius = "5px";
                        element.style.whiteSpace = "pre-wrap";
                        element.style.wordWrap = "break-word";
                        element.style.fontFamily = "monospace";
                        element.style.fontSize = "12px";
                        element.style.maxHeight = "80vh";
                        element.style.overflow = "auto";
                        element.style.border = "1px solid #ddd";
                        element.textContent = plainTextContent;

                        console.log("âœ“ ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆå½¢å¼ã§è¡¨ç¤ºã—ã¾ã™");
                    }
                    break;

                case "text/html":

                    element = document.createElement("iframe");
                    element.src = blobURL;
                    element.style.width = "100%";
                    element.style.height = "100vh";
                    // element.style.minHeight = "100vh";
                    element.style.border = "none";
                    element.style.display = "block";
                    break;

                default:
                    element = document.createElement("p");
                    element.textContent = `å¯¾å¿œã—ã¦ã„ãªã„MIMEã‚¿ã‚¤ãƒ—: ${mimeType}`;
                    break;
            }

            containerElement.appendChild(element);
        }


        // Base64ã®ä¸æ­£æ–‡å­—ã‚’é™¤å»ã—ã€4ã®å€æ•°ã«ã™ã‚‹
        function sanitizeBase64(base64) {
            // å‰å¾Œã®ç©ºç™½ã‚’å‰Šé™¤
            // base64 = base64.trim();
            // base64 = base64.replace(/[\s\n\r\t]/g, '');
            // base64 = base64.replace(/=+$/, '');


            // console.log("âœ“ sanitizeBase64 å‡¦ç†å¾Œ:");
            // console.log("  å‡¦ç†å¾Œãƒ‡ãƒ¼ã‚¿é•·:", base64.length);
            // console.log("  é•·ã• % 4:", base64.length % 4);
            // console.log("  ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°:", (base64.match(/=+$/)?.[0] || 'ãªã—'));
            // console.log("  æœ«å°¾10æ–‡å­—:", base64.substring(base64.length - 10));



            return base64;
        }


        // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šãƒ‡ãƒ¼ã‚¿è§£æãƒ„ãƒ¼ãƒ«
        async function analyzeNFTDriveData(address) {
            initializeFetcher(address);

            try {
                const allTxs = await fetcher.getAllTransactionsAggregate(address);
                const result = await fetcher.fetchTransactionsByHashes(allTxs);

                // è§£æå®Ÿè¡Œ
                const analysis = fetcher.analyzNFTDriveData(result);

                console.log("=== NFTDriveData è©³ç´°è§£æ ===");
                console.log(JSON.stringify(analysis, null, 2));

                // HTMLã«è©³ç´°çµæœã‚’è¡¨ç¤º
                document.getElementById('result').innerHTML = `<pre style="background: #f0f0f0; padding: 10px; overflow: auto; max-height: 400px;">${JSON.stringify(analysis, null, 2)}</pre>`;

                return analysis;
            } catch (error) {
                console.error("è§£æã‚¨ãƒ©ãƒ¼:", error);
            }
        }

        function displayTransactionAnalysis(debugInfo) {
            const { transactionContinuity } = debugInfo;
            if (!transactionContinuity) return;

            const {
                transactionArrayCount,
                messageNumbers,
                missingMessages,
                messageRange,
                isComplete,
                completenessPercentage
            } = transactionContinuity;

            let html = `<div style="background: ${isComplete ? '#d4edda' : '#fff3cd'}; border: 2px solid ${isComplete ? '#28a745' : '#ff9800'}; padding: 15px; margin: 10px 0; border-radius: 5px;">`;
            html += `<h3 style="color: ${isComplete ? '#155724' : '#ff6600'}; margin-top: 0;">${isComplete ? 'âœ“' : 'âš '} ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ åˆ†æ</h3>`;

            html += `<table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">`;
            html += `<tr style="background: ${isComplete ? '#c3e6cb' : '#ffe0b2'};">
                <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">é …ç›®</th>
                <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">å€¤</th>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>Txé…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">0 ï½ ${transactionArrayCount - 1} (åˆè¨ˆ${transactionArrayCount}å€‹)</td>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç•ªå·ç¯„å›²</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">${messageRange.min} ï½ ${messageRange.max}</td>
            </tr>`;

            const expectedMsg = messageRange.max - messageRange.min + 1;
            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>æœŸå¾…ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">${expectedMsg}å€‹</td>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>å®Ÿå–å¾—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>${messageNumbers.length}å€‹</strong></td>
            </tr>`;

            html += `<tr style="background: ${isComplete ? '#c3e6cb' : '#ffccbc'};">
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: ${isComplete ? 'green' : 'red'}">${missingMessages.length}å€‹</strong></td>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>å®Œå…¨æ€§</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>${completenessPercentage}%</strong></td>
            </tr>`;
            html += `</table>`;

            if (!isComplete && missingMessages.length > 0) {
                html += `<h4 style="color: red;">ğŸ“ æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç•ªå·:</h4>`;
                html += `<p style="background: #fff; padding: 10px; border-radius: 3px; font-family: monospace; word-break: break-all; border: 1px solid #ccc;">`;
                html += missingMessages.join(', ');
                html += `</p>`;
                html += `<p style="font-size: 12px; color: #666;">â€» ã“ã‚Œã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç•ªå·ãŒãƒã‚§ãƒ¼ãƒ³ã‹ã‚‰æ¬ æã—ã¦ã„ã¾ã™</p>`;
            } else {
                html += `<p style="color: green; font-weight: bold;">âœ“ ã™ã¹ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæƒã£ã¦ã„ã¾ã™</p>`;
            }

            html += `</div>`;
            document.getElementById('debugInfo').innerHTML += html;
        }

        // æ¬ ææ¤œå‡ºã®æ¤œè¨¼çµæœã‚’è¡¨ç¤º
        function displayVerificationResult(verification) {
            let html = `<div style="background: #fff3cd; border: 2px solid #ffc107; padding: 15px; margin: 10px 0; border-radius: 5px;">`;
            html += `<h4>æ¬ ææ¤œå‡ºã®æ¤œè¨¼</h4>`;
            html += `<p>çŠ¶æ…‹: <strong style="color: ${verification.isValid ? 'green' : 'red'}">${verification.isValid ? 'âœ“ æ­£å¸¸' : 'âœ— ç•°å¸¸'}</strong></p>`;

            if (verification.errors.length > 0) {
                html += `<p style="color: red;">ã‚¨ãƒ©ãƒ¼:</p><ul>`;
                verification.errors.forEach(err => {
                    html += `<li>${err}</li>`;
                });
                html += `</ul>`;
            }

            html += `<p>ç¯„å›²: ${verification.details.expectedRange.min} ï½ ${verification.details.expectedRange.max} (æœŸå¾…${verification.details.expectedRange.count}å€‹)</p>`;
            html += `<p>å®Ÿå–å¾—: ${verification.details.totalExtracted}å€‹</p>`;
            html += `<p>æ¬ æ: ${verification.details.lostCount}å€‹</p>`;

            html += `</div>`;
            document.getElementById('debugInfo').innerHTML += html;
        }




















        //WABèª¿æŸ»

        // â˜… WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è§£æ
        function analyzeWAVMetadata(byteArray) {
            const view = new DataView(byteArray.buffer, byteArray.byteOffset, byteArray.byteLength);

            const result = {
                riffHeader: null,
                fileSize: 0,
                format: null,
                dataChunkSize: 0,
                actualDataSize: byteArray.length,
                match: false,
                isMismatch: false
            };

            try {
                // RIFF ãƒ˜ãƒƒãƒ€ãƒ¼ç¢ºèª
                const riff = String.fromCharCode(
                    view.getUint8(0),
                    view.getUint8(1),
                    view.getUint8(2),
                    view.getUint8(3)
                );

                if (riff !== 'RIFF') {
                    console.warn("âš  RIFFãƒ˜ãƒƒãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
                    return result;
                }

                result.riffHeader = riff;

                // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºï¼ˆãƒªãƒˆãƒ«ã‚¨ãƒ³ãƒ‡ã‚£ã‚¢ãƒ³ï¼‰
                result.fileSize = view.getUint32(4, true) + 8; // +8 ã¯ RIFF ãƒ˜ãƒƒãƒ€ãƒ¼è‡ªä½“

                // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆç¢ºèª
                result.format = String.fromCharCode(
                    view.getUint8(8),
                    view.getUint8(9),
                    view.getUint8(10),
                    view.getUint8(11)
                );

                // "data" ãƒãƒ£ãƒ³ã‚¯ã‚’æ¢ã™
                let dataChunkPos = -1;
                for (let i = 12; i < byteArray.length - 4; i++) {
                    if (
                        view.getUint8(i) === 0x64 &&     // 'd'
                        view.getUint8(i + 1) === 0x61 && // 'a'
                        view.getUint8(i + 2) === 0x74 && // 't'
                        view.getUint8(i + 3) === 0x61    // 'a'
                    ) {
                        dataChunkPos = i;
                        break;
                    }
                }

                if (dataChunkPos !== -1) {
                    result.dataChunkSize = view.getUint32(dataChunkPos + 4, true);
                    result.actualDataInChunk = dataChunkPos + 8 + result.dataChunkSize;
                }

                // å®¹é‡ã®ä¸ä¸€è‡´ã‚’ãƒã‚§ãƒƒã‚¯
                result.match = (result.fileSize === result.actualDataSize);
                result.isMismatch = !result.match;

                console.log("=== WAVãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è§£æ ===");
                console.log("RIFFãƒ˜ãƒƒãƒ€ãƒ¼:", result.riffHeader);
                console.log("ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è¨˜è¼‰ã‚µã‚¤ã‚º:", result.fileSize, "bytes");
                console.log("å®Ÿãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º:", result.actualDataSize, "bytes");
                console.log("dataãƒãƒ£ãƒ³ã‚¯è¨˜è¼‰ã‚µã‚¤ã‚º:", result.dataChunkSize, "bytes");
                console.log("å®¹é‡ä¸€è‡´:", result.match);
                console.log("ä¸ä¸€è‡´:", result.isMismatch);

                if (result.isMismatch) {
                    const diff = result.actualDataSize - result.fileSize;
                    console.log(`âš  ã‚µã‚¤ã‚ºå·®åˆ†: ${Math.abs(diff)} bytes (${(Math.abs(diff) / 1024).toFixed(2)} KB)`);
                }

            } catch (e) {
                console.error("WAVãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼:", e.message);
            }

            return result;
        }

        // displayLostTransactionAnalysis ã‚’ä¿®æ­£
        function displayLostTransactionAnalysis(debugInfo) {
            const { transactionContinuity } = debugInfo;
            if (!transactionContinuity) return;

            const {
                transactionArrayCount,
                messageNumbers,
                missingMessages,
                messageRange,
                isComplete,
                completenessPercentage
            } = transactionContinuity;

            let html = `<div style="background: ${isComplete ? '#d4edda' : '#fff3cd'}; border: 2px solid ${isComplete ? '#28a745' : '#ff9800'}; padding: 15px; margin: 10px 0; border-radius: 5px;">`;
            html += `<h3 style="color: ${isComplete ? '#155724' : '#ff6600'}; margin-top: 0;">${isComplete ? 'âœ“' : 'âš '} ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ§‹é€ åˆ†æ</h3>`;

            html += `<table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">`;
            html += `<tr style="background: ${isComplete ? '#c3e6cb' : '#ffe0b2'};">
        <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">é …ç›®</th>
        <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">å€¤</th>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>Txé…åˆ—ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç¯„å›²</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;">0 ï½ ${transactionArrayCount - 1} (åˆè¨ˆ${transactionArrayCount}å€‹)</td>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç•ªå·ç¯„å›²</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;">${messageRange.min} ï½ ${messageRange.max}</td>
    </tr>`;

            const expectedMsg = messageRange.max - messageRange.min + 1;
            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>æœŸå¾…ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;">${expectedMsg}å€‹</td>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>å®Ÿå–å¾—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>${messageNumbers.length}å€‹</strong></td>
    </tr>`;

            html += `<tr style="background: ${isComplete ? '#c3e6cb' : '#ffccbc'};">
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: ${isComplete ? 'green' : 'red'}">${missingMessages.length}å€‹</strong></td>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>å®Œå…¨æ€§</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>${completenessPercentage}%</strong></td>
    </tr>`;
            html += `</table>`;

            if (!isComplete && missingMessages.length > 0) {
                html += `<h4 style="color: red;">ğŸ“ æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç•ªå·:</h4>`;
                html += `<p style="background: #fff; padding: 10px; border-radius: 3px; font-family: monospace; word-break: break-all; border: 1px solid #ccc;">`;
                html += missingMessages.join(', ');
                html += `</p>`;
            } else {
                html += `<p style="color: green; font-weight: bold;">âœ“ ã™ã¹ã¦ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæƒã£ã¦ã„ã¾ã™</p>`;
            }

            html += `</div>`;

            if (!document.getElementById('debugInfo')) {
                const debugDiv = document.createElement('div');
                debugDiv.id = 'debugInfo';
                document.body.appendChild(debugDiv);
            }
            document.getElementById('debugInfo').innerHTML += html;

            // â˜… ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’è¿½åŠ 
            console.log("=== displayLostTransactionAnalysis å®Ÿè¡Œ ===");
            console.log("debugInfo:", debugInfo);
            console.log("aggregateTransactions:", debugInfo.aggregateTransactions);
            console.log("missingMessages:", missingMessages);

            // â˜… æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚ºåˆ†æã‚’è¿½åŠ ï¼ˆå…¨ä½“ã®aggTxesã‚’ä½¿ç”¨ï¼‰
            if (missingMessages.length > 0) {
                console.log("âœ“ æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚ã‚Š - åˆ†æé–‹å§‹");

                // aggregateTransactionsé…åˆ—ãŒã‚ã‚‹å ´åˆ
                if (debugInfo.aggregateTransactions && Array.isArray(debugInfo.aggregateTransactions)) {
                    console.log("âœ“ aggregateTransactions é…åˆ—ã‚’æ¤œå‡º");
                    const analysis = analyzeActualMissingMessageSize(debugInfo.aggregateTransactions, missingMessages);
                    console.log("âœ“ åˆ†æå®Œäº†:", analysis);
                    displayMissingMessageAnalysis(analysis);
                } else {
                    console.warn("âš  aggregateTransactionsãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
                    console.warn("debugInfo ã®ã‚­ãƒ¼:", Object.keys(debugInfo));
                }
            } else {
                console.log("æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã— - åˆ†æã‚¹ã‚­ãƒƒãƒ—");
            }
        }
        function displayWAVAnalysis(wavMetadata) {
            if (!wavMetadata || !wavMetadata.riffHeader) return;

            let html = `<div style="background: #e3f2fd; border: 2px solid #2196f3; padding: 15px; margin: 10px 0; border-radius: 5px;">`;
            html += `<h3 style="color: #1976d2; margin-top: 0;">ğŸµ WAVãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è§£æ</h3>`;

            html += `<table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">`;
            html += `<tr style="background: #bbdefb;">
                <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">é …ç›®</th>
                <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">å€¤</th>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>RIFFãƒ˜ãƒƒãƒ€ãƒ¼</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">${wavMetadata.riffHeader}</td>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿è¨˜è¼‰ã‚µã‚¤ã‚º</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">${(wavMetadata.fileSize / (1024 * 1024)).toFixed(2)} MB (${wavMetadata.fileSize} bytes)</td>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>å®Ÿãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">${(wavMetadata.actualDataSize / (1024 * 1024)).toFixed(2)} MB (${wavMetadata.actualDataSize} bytes)</td>
            </tr>`;

            html += `<tr>
                <td style="padding: 8px; border: 1px solid #ccc;"><strong>dataãƒãƒ£ãƒ³ã‚¯è¨˜è¼‰ã‚µã‚¤ã‚º</strong></td>
                <td style="padding: 8px; border: 1px solid #ccc;">${(wavMetadata.dataChunkSize / (1024 * 1024)).toFixed(2)} MB (${wavMetadata.dataChunkSize} bytes)</td>
            </tr>`;

            if (wavMetadata.isMismatch) {
                const diff = wavMetadata.actualDataSize - wavMetadata.fileSize;
                html += `<tr style="background: #ffebee;">
                    <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: #d32f2f;">âš  ã‚µã‚¤ã‚ºä¸ä¸€è‡´</strong></td>
                    <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: #d32f2f;">${Math.abs(diff)} bytes (${(Math.abs(diff) / 1024).toFixed(2)} KB)</strong></td>
                </tr>`;
            } else {
                html += `<tr style="background: #e8f5e9;">
                    <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: #2e7d32;">âœ“ å®¹é‡ä¸€è‡´</strong></td>
                    <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: #2e7d32;">ä¸€è‡´ã—ã¦ã„ã¾ã™</strong></td>
                </tr>`;
            }

            html += `</table>`;

            if (wavMetadata.isMismatch) {
                html += `<p style="font-size: 12px; color: #666;">
                    <strong>åŸå› ã®æ¨æ¸¬ï¼š</strong><br/>
                    â€¢ ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®ã€ŒfileSizeã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯å›ºå®šå€¤<br/>
                    â€¢ å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚ºãŒç•°ãªã£ã¦ã„ã‚‹<br/>
                    â€¢ æ¬ æãƒ‡ãƒ¼ã‚¿ã¯ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã¨ç•°ãªã‚‹ã‚µã‚¤ã‚ºã§å¾©å…ƒã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§
                </p>`;
            }

            html += `</div>`;

            if (!document.getElementById('debugInfo')) {
                const debugDiv = document.createElement('div');
                debugDiv.id = 'debugInfo';
                document.body.appendChild(debugDiv);
            }
            document.getElementById('debugInfo').innerHTML += html;
        }

        // æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸åˆ†æã‚’è¡¨ç¤º
        function displayMissingMessageAnalysis(analysis) {
            let html = `<div style="background: #fff8e1; border: 2px solid #ff9800; padding: 15px; margin: 10px 0; border-radius: 5px;">`;
            html += `<h3 style="color: #e65100; margin-top: 0;">ğŸ” æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚ºåˆ†æ</h3>`;

            html += `<table style="width: 100%; border-collapse: collapse; margin-bottom: 15px;">`;
            html += `<tr style="background: #ffe0b2;">
        <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">é …ç›®</th>
        <th style="padding: 8px; border: 1px solid #ccc; text-align: left;">å€¤</th>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>å¹³å‡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚º</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;">${analysis.avgMessageSize.toFixed(0)} bytes</td>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>${analysis.missingMessageDetails.length}å€‹</strong></td>
    </tr>`;

            html += `<tr>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¨å®šã‚µã‚¤ã‚º</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: #ff6600;">${(analysis.avgMissingSize / 1024).toFixed(2)} KB</strong></td>
    </tr>`;

            html += `<tr style="background: #ffccbc;">
        <td style="padding: 8px; border: 1px solid #ccc;"><strong>ã‚ã‚‹ã¹ãç·ã‚µã‚¤ã‚º</strong></td>
        <td style="padding: 8px; border: 1px solid #ccc;"><strong style="color: #d32f2f;">${((analysis.avgMissingSize) / (1024 * 1024)).toFixed(2)} MB</strong></td>
    </tr>`;

            html += `</table>`;

            html += `<p style="font-size: 12px; color: #666;">
        <strong>é‡è¦ãªç™ºè¦‹ï¼š</strong><br/>
        â€¢ æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${analysis.missingMessageDetails.length}å€‹ Ã— å¹³å‡ ${analysis.avgMessageSize.toFixed(0)} bytes<br/>
        â€¢ = æ¨å®š ${(analysis.avgMissingSize / 1024).toFixed(2)} KB ã®ã‚µã‚¤ã‚ºãŒä¸è¶³ã—ã¦ã„ã‚‹ã¯ãš<br/>
        â€¢ ã—ã‹ã—å®Ÿãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºã¯åŒã˜ â†’ <strong style="color: #d32f2f;">æ¬ æã¯å®Ÿãƒ‡ãƒ¼ã‚¿ã§ã¯ãªãç©ºãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ã‚ã‚‹å¯èƒ½æ€§</strong>
    </p>`;

            html += `</div>`;

            if (!document.getElementById('debugInfo')) {
                const debugDiv = document.createElement('div');
                debugDiv.id = 'debugInfo';
                document.body.appendChild(debugDiv);
            }
            document.getElementById('debugInfo').innerHTML += html;
        }

        // â˜… æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’èª¿æŸ»
        function analyzeActualMissingMessageSize(aggTxes, missingMessages) {
            console.log("analyzeActualMissingMessageSize é–‹å§‹");
            console.log("aggTxes.length:", aggTxes.length);
            console.log("missingMessages.length:", missingMessages.length);

            const result = {
                totalMissingSize: 0,
                missingMessageDetails: [],
                avgMessageSize: 0,
                avgMissingSize: 0
            };

            // å…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
            let totalSize = 0;
            let totalMessages = 0;
            const messageSizes = [];

            for (let i = 15; i < aggTxes.length; i++) {
                if (aggTxes[i][0] && aggTxes[i][0].transaction && aggTxes[i][0].transaction.message) {
                    const msgNum = Number(aggTxes[i][0].transaction.message);
                    if (!isNaN(msgNum)) {
                        const messageData = aggTxes[i][0].transaction.message;
                        const messageSize = messageData.length;
                        messageSizes.push({
                            messageNumber: msgNum,
                            size: messageSize
                        });
                        totalSize += messageSize;
                        totalMessages++;
                    }
                }
            }

            result.avgMessageSize = totalMessages > 0 ? totalSize / totalMessages : 0;

            // æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ¨å®šã‚µã‚¤ã‚º
            result.avgMissingSize = missingMessages.length * result.avgMessageSize;

            // æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è©³ç´°
            missingMessages.forEach(msgNum => {
                const surroundingMessages = messageSizes.filter(m =>
                    m.messageNumber >= msgNum - 2 && m.messageNumber <= msgNum + 2
                );
                result.missingMessageDetails.push({
                    messageNumber: msgNum,
                    surroundingMessages: surroundingMessages,
                    estimatedSize: result.avgMessageSize
                });
            });

            console.log("=== æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚ºåˆ†æ ===");
            console.log("å…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°:", totalMessages);
            console.log("å…¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç·ã‚µã‚¤ã‚º:", totalSize, "bytes");
            console.log("å¹³å‡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚º:", result.avgMessageSize.toFixed(0), "bytes");
            console.log("æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°:", missingMessages.length);
            console.log("æ¬ æãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ¨å®šç·ã‚µã‚¤ã‚º:", result.avgMissingSize.toFixed(0), "bytes");
            console.log("ã‚ã‚‹ã¹ãç·ã‚µã‚¤ã‚º:", (totalSize + result.avgMissingSize).toFixed(0), "bytes");
            console.log("å®Œå…¨ãªåˆ†æçµæœ:", result);

            return result;
        }
    </script>
</body>

</html>